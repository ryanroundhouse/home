# Prompt: Build the Full WebSocket Backend for the Site Chatroom

Build a production-ready backend for a vanilla HTML/CSS/JS chatroom frontend.

## Context
- Frontend is a static site (no framework, no build step required for browser code).
- The chatroom UI already exists and will connect via WebSockets.
- No authentication is required (anonymous users).
- Users can change their display name at any time (names cannot contain spaces).
- Users get a random avatar SVG on the frontend; backend should store/relay `avatarId` per message (integer generated by client).
- Users can create any room and join any room (one active room at a time client-side).
- Joining a room must return full message history capped at **500** most recent messages.
- Messages support normal text and emotes (`/emote <text>` is parsed by frontend and sent as type `emote`).
- Mentions are plain text `@name` (frontend plays gong on mention).

## Deployment assumption
- WebSocket server hostname: `rgbot.graham.pub`
- Assume TLS WebSocket endpoint (recommended): `wss://rgbot.graham.pub:8443`
- If you choose a different port/path, keep it configurable and document it clearly.

## Required backend behavior

### Core features
1. Anonymous connections over WebSocket.
2. Room discovery/listing (all rooms visible to everyone).
3. Create room if it doesnâ€™t exist (idempotent by normalized room id/name).
4. Join room (server returns room metadata + last 500 messages).
5. Send message to room (`message` or `emote`).
6. Broadcast new messages in realtime to all clients currently joined to that room.
7. Update room list metadata (message counts / last activity) for connected clients.
8. Allow profile updates (`name`, `avatarId`) at any time.
9. Validate names: no spaces, non-empty, length-limited.
10. Validate/sanitize room names and message lengths.

### Persistence requirements
- Persist room metadata and messages on the server.
- Message history per room should be retained but only the most recent 500 must be returned on join.
- Use a simple storage option suitable for self-hosting (SQLite preferred for simplicity).
- Server must survive restarts without losing room history.

### Operational requirements
- Heartbeat/keepalive (ping/pong or app-level ping).
- Graceful handling of malformed JSON and unknown message types.
- Reconnect-safe protocol (client can reconnect and rejoin).
- Basic rate limiting / spam controls (per connection and/or per IP).
- Structured logs for connect/disconnect/errors.
- Config via environment variables (host, port, allowed origin(s), db path, max message length, etc.).
- CORS/origin checks appropriate for WebSocket upgrade requests.

## Recommended stack (but choose pragmatically)
- **Node.js** (LTS)
- `ws` for WebSocket server
- `better-sqlite3` or `sqlite3` for persistence
- Optional: `pino` for logs
- Keep architecture small and readable

## WebSocket protocol contract (implement this exactly unless you have a strong reason)
Use JSON messages with a top-level `type` string.

### Client -> Server messages

#### 1) hello
Sent immediately after WebSocket opens.
```json
{
  "type": "hello",
  "protocol": "rg-chat-v1",
  "sessionId": "client-generated-stable-id",
  "profile": {
    "name": "guest123",
    "avatarId": 1234
  },
  "resumeRoomId": "lobby"
}
```
Rules:
- `name` cannot contain spaces.
- `avatarId` should be an integer.
- `resumeRoomId` optional; server should auto-join if it exists (or ignore safely).

#### 2) set_profile
```json
{
  "type": "set_profile",
  "name": "newname",
  "avatarId": 5678
}
```
Rules:
- Name must pass validation (`\S+`, max 24 chars recommended).
- Backend updates connection-scoped profile for future messages.

#### 3) create_room
```json
{
  "type": "create_room",
  "name": "lobby"
}
```
Rules:
- If room exists after normalization, return success for existing room.
- Create if missing, then include updated room list.

#### 4) join_room
```json
{
  "type": "join_room",
  "roomId": "lobby"
}
```
Rules:
- Only one active room per connection is necessary.
- Server returns room info + last 500 messages.

#### 5) send_message
```json
{
  "type": "send_message",
  "roomId": "lobby",
  "message": {
    "type": "message",
    "text": "hello world"
  }
}
```
or emote:
```json
{
  "type": "send_message",
  "roomId": "lobby",
  "message": {
    "type": "emote",
    "text": "waves"
  }
}
```
Rules:
- Server should trust room membership only if connection is currently joined to that room.
- Stamp canonical server timestamp and message id.
- Relay profile fields (`name`, `avatarId`) from current server-side profile.

#### 6) ping (optional app-level)
```json
{ "type": "ping", "ts": 1730000000000 }
```

### Server -> Client messages

#### 1) welcome
Sent after successful `hello`.
```json
{
  "type": "welcome",
  "protocol": "rg-chat-v1",
  "self": {
    "clientId": "server-connection-id",
    "name": "guest123",
    "avatarId": 1234
  },
  "activeRoomId": "lobby",
  "rooms": [
    {
      "id": "lobby",
      "name": "lobby",
      "createdAt": 1730000000000,
      "messageCount": 14,
      "lastMessageTs": 1730000012345
    }
  ]
}
```
Notes:
- `activeRoomId` optional if no room joined yet.
- `rooms` may be empty initially.

#### 2) room_list
Broadcast or send after room creation / message activity changes room metadata.
```json
{
  "type": "room_list",
  "rooms": [
    {
      "id": "lobby",
      "name": "lobby",
      "createdAt": 1730000000000,
      "messageCount": 14,
      "lastMessageTs": 1730000012345
    }
  ]
}
```

#### 3) joined_room
Sent after `join_room` succeeds.
```json
{
  "type": "joined_room",
  "room": {
    "id": "lobby",
    "name": "lobby",
    "createdAt": 1730000000000
  },
  "messages": [
    {
      "id": "msg_abc",
      "ts": 1730000012345,
      "authorId": "conn_1",
      "name": "guest123",
      "avatarId": 1234,
      "type": "message",
      "text": "hello"
    }
  ]
}
```
Rules:
- `messages` must contain at most 500, oldest-to-newest.

#### 4) message
Broadcast to clients in the room when a message is sent.
```json
{
  "type": "message",
  "roomId": "lobby",
  "message": {
    "id": "msg_abc",
    "ts": 1730000012345,
    "authorId": "conn_1",
    "name": "guest123",
    "avatarId": 1234,
    "type": "message",
    "text": "hello"
  }
}
```

#### 5) profile_ack
```json
{
  "type": "profile_ack",
  "self": {
    "clientId": "server-connection-id",
    "name": "newname",
    "avatarId": 5678
  }
}
```

#### 6) pong (optional)
```json
{ "type": "pong", "ts": 1730000000000 }
```

#### 7) error
```json
{
  "type": "error",
  "code": "INVALID_NAME",
  "message": "Names cannot contain spaces.",
  "requestType": "set_profile"
}
```

## Data model (SQLite suggestion)
Create a minimal schema (example):

### `rooms`
- `id` TEXT PRIMARY KEY
- `name` TEXT NOT NULL
- `created_at` INTEGER NOT NULL
- `last_message_ts` INTEGER NULL
- `message_count` INTEGER NOT NULL DEFAULT 0

### `messages`
- `id` TEXT PRIMARY KEY
- `room_id` TEXT NOT NULL REFERENCES rooms(id)
- `ts` INTEGER NOT NULL
- `author_id` TEXT NOT NULL
- `name` TEXT NOT NULL
- `avatar_id` INTEGER NOT NULL
- `type` TEXT NOT NULL CHECK(type IN ('message','emote'))
- `text` TEXT NOT NULL

Indexes:
- `messages(room_id, ts)`
- `rooms(last_message_ts)`

## Validation + normalization rules
- Name:
  - trim
  - no spaces (`/\S+/` whole string)
  - max 24 chars
  - fallback to generated guest name if invalid on `hello`
- Room name:
  - trim
  - max 40 chars (display name)
  - normalize room id similar to slug: lowercase, remove unsupported chars, spaces -> `-`
  - if normalization empties string, reject
- Message text:
  - trim
  - max 400 chars
  - reject empty
- Message type:
  - only `message` or `emote`

## Deliverables
Produce all code and docs needed to run this backend:
1. `server/` implementation (or repo root if you prefer)
2. `package.json` scripts (`dev`, `start`)
3. `.env.example`
4. README with local run + production deployment instructions
5. DB initialization/migrations strategy
6. Reverse proxy notes (nginx/caddy) for `wss://rgbot.graham.pub:8443`
7. Basic tests for protocol validation + room/message persistence

## Non-goals
- Authentication/accounts
- End-to-end encryption
- Private rooms/permissions
- Rich media uploads

## Implementation quality bar
- Small, maintainable modules
- Clear protocol constants/types
- Defensive parsing of all inbound JSON
- No silent failures (return `error` messages)
- Useful logs for ops

When implementing, optimize for reliability and simplicity over feature creep.
